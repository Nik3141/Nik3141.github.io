<!DOCTYPE HTML>
<html lang="en-US">

<head>
	<meta charset="UTF-8">

	<link rel="shortcut icon" href="resources/favicon.jpg">
	<title>Programming Fundamentals</title>
	
	<link rel="stylesheet" type="text/css" href="styles/style.css">
	<base target="_blank">
</head>

<body>
	<div id="bodycontent">
	
		<br>
		<h4><p><a target="_self" href="index.html">Home</a></p></h4>
		<h1>Programming Fundamentals</h1>
		<hr>
		
		<h3><p>Please note that any code on this page is <a href="https://economictimes.indiatimes.com/definition/pseudocode"><i>pseudocode</i></a>, meaning it won't work in any actual programming language.</p></h3>
		
		<h2>Binary Numbers</h2>
		
		<h3>
			<p>
				Binary numbers are so important for the study of computer science that I put them on their own special page <a href="binary-numbers.html">here</a>.
				If you already know how binary numbers and binary operations work, feel free to skip that section.
				If not, please read that page before continuing with this one, because this one will assume that you understand them.
				I suggest you read it just to make sure that you haven't missed any information.
			</p>
		</h3>
		
		<h2>Algorithms</h2>
		
		<h3>
			<p>
				Computers, in their most basic form, are machines that follow sets of instructions which we give them, which we call <i>algorithms</i>.
				That's all they are! Almost anything can be a computer: for examples see <a href="https://www.youtube.com/watch?v=8BOvLL8ok8I">this</a> video about a computer made of a marble dropper or <a href="https://www.youtube.com/watch?v=pdmODVYPDLA">this</a> video about a computer made in the card game Magic the Gathering.
				Algorithms form the basis for modern computer science.
			</p>
			<p>
				There are many types of algorithms, and they all serve different purposes.
				For example, there are algorithms which add two numbers, or compare them to determine which is bigger, or sort lists of names alphabetically, or determine which pages should show up first in a Google search.
				There can be many different algorithms that achieve the same thing, but depending on the specifics of the application, we might choose one over the other.
				If we value speed, we might pick the fastest algorithm.
				If we value being able to run it on many computers, we might choose the least <i>resource intensive</i> algorithm.
				This would be the one that uses up the least amount of processing power and/or memory.
			</p>
			<p>
				At the basis of an algorithm is the idea of the manipulation of <i>data</i>.
			</p>
		</h3>
		
		<h2>Primitive Data Types</h2>
		
		<h3>
			<p>
				Data is information; data can be a number, or a true or false value, or a word, or a binary number.
				Data has two components: the value of the data itself and the <i>metadata</i> of the data, which refers to information about the data, such as when it was created or what it represents or who created it.
				We can categorize the values of data into several <i>datatypes</i>.
			</p>
			<p>
				Firstly, there is the <i>Boolean</i> data type, which has only two possible values: True or False.
				It can also be represented by a single bit, meaning a 1 or 0 value, where 1 is True and 0 is False.
			</p>
			<p>
				In terms of integer values (...-3, -2, -1, 0, 1, 2, 3...) there are bits, nibbles, bytes, shorts, ints, and longs.
				The difference between all of these is the amount of data which can be stored, ie the limits of what can be represented in each type.
				Additionally, because each of these are defined only by their size in bits (1s or 0s in the binary representation of the number), they can hold either unsigned (only positive) or signed (negative numbers using <a href="binary-numbers.html#two's-complement">Two's Complement</a> or some other representation scheme) numbers.
			</p>
			<p>
				- A bit can only hold a 0 or a 1, making it equivalent to a boolean.<br>
				- A nibble (4 bits) can hold 16 values, either 0 to 15 if unsigned or -8 to +7 if signed.<br>
				- A byte (8 bits or 2 nibbles) can hold 256 values, either 0 to 255 unsigned or -128 to +127 if signed.<br>
				- A short (16 bits or 2 bytes) can hold 65536 values, so 0 to 65,535 unsigned or −32,768 to +32,767 signed.<br>
				- A signed int (32 bits, or 4 bytes) holds a value within the bounds of −(2<sup>31</sup>) to 2<sup>31</sup> − 1.<br>
				- A signed long (64 bits or 8 bytes) holds a value within the bounds of −(2<sup>63</sup>) to 2<sup>63</sup> − 1.<br>
			</p>
			<p>
				Another datatype is a decimal number, such as 5.327, normally referred to as a <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic">floating-point number</a>.
				These numbers are stored in a similar way to <a href="https://en.wikipedia.org/wiki/Scientific_notation">scientific notation</a>, and are sometimes called <i>doubles</i>.
			</p>
			<p>
				An important datatype is the 'char' datatype, which stands for a single character.
				Computers can only deal in binary, so relating a character to a binary representation of it is very important; this is called <i>character encoding</i>.
				Some examples of character encoding from the pre-digital age are Morse code or signal flags used in ancient times (from <a href="https://en.wikipedia.org/wiki/Character_encoding">Wikipedia</a>).
				Right now, the two most common character encodings are ASCII and Unicode, although Unicode is steadily gaining traction because of its greater ability to represent international symbols not found in the English language.
			</p>
			<p>
				Take a look at the ASCII table on <a href="https://ascii.cl/">this</a> page. ASCII uses 7 bits to represent the numbers 0 - 127, which each have an associated symbol.
				For example, lowercase letter 'a' is represented in ASCII by the number 97.
				You'll also see that at the beginning are some symbols which seem to be rather arbitrary combinations of capital letters.
				These are actually non-character symbols, such as a newline or a tab or an escape character, which don't have a symbol but are important to be able to represent.
				If you are wondering, the HEX column on the table is referring to the hexadecimal (Base 16) representation.
				Just like we can represent numbers in base 2 and base 10, we can represent them in any base, and base 16 happens to be very useful for computer programming.
			</p>
			<p>
				Moving on to Unicode, you may have seen 'UTF-8' or 'UTF-16' or 'UTF-32' at some point on a computer. These are all Unicode standards, where the number after the 'UTF-' refers to the number of bits used.
				UTF-8 encoding uses 8 bits, UTF-16 uses 16, etc. Understanding that a character/symbol can be represented by a number according to an encoding standard is an important concept.
			</p>
		</h3>
		
		<h2>Data Structures</h2>
		
		<h3>
			<p>
				The datatypes that you just read about are often called <i>primitive data types</i>, because they are native or 'built-in' to many programming languages.
				Different programming languages may differ slightly in terms of what datatypes are native or not, but those types that are above are built-in to most languages.
				Now, we're going to turn to <i>data structures</i>, which allow us to organize data so that it can be stored and retrieved.
				Datastructures can have different organizational schemes, which is primarily what sets different datastructure types apart.
				Some data structures are primitive in some languages, while in others, they aren't. It really depends on the language.
				For now we'll deal with datastructures which use a key-value organizational scheme, where a value in the datastructure is correlated to a key which 'points' to where the value is stored.
			</p>
			<p>
				The first data structure we'll look at is an <i>array</i>. Arrays are sometimes called lists or vectors, or matricies if they are multidimensional (we'll get to this later).
				To understand arrays, let's construct an analogy.
				An array is like a table with a placard on it. The placard is the name of the array - it's a piece of metadata about the array.
				The table has multiple cups in a neat, orderly row on it, each labeled with a unique number, starting from 0 and then increasing from there.
				Let's suppose that there are 4 cups, labeled 0, 1, 2, and 3.
				Inside each cup we can put a primitive data type, such as a number stored as an int,
				so for example the 0th cup can have the number 5, the cup labeled '1' can have the number 7, the cup labeled '2' can have the number 3, and the cup labeled 3 can have the number '-13'.
				Now we can say that we have an <i>array of ints</i>, or an <i>int array</i>.
				In some languages, you are allowed to mix what types are in each cup, but for now we will assume that a valid array must have the same data type in every filled cup.
			</p>
		</h3>
		<table>
			<tr>
				<th>Index:</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>

			</tr>
			<tr>
				<th>Value:</td>
				<td>5</td>
				<td>7</td>
				<td>3</td>
				<td>-13</td>

			</tr>
		</table>
		<h3>
			<p>
				Let's define some terminology: firstly, an <i>element</i> in the array is a value that we put in a cup.
				Each element has an <i>index</i>, which basically refers to the number on the cup it resides in.
				Arrays in most languages are <i>0-indexed</i>, which means their index numbers start at 0 rather than 1.
				This might seem confusing in the beginning, but if you live with it for long enough it will become second nature to refer to the first cup as the 0th index.
				Arrays are <i>ordered</i>, which means what it says: there is a 'first' element, a 'second' element, all the way up to a 'last' element.
				The length/size of an array is the number of cups we have; it is the number of spaces we have to put elements.
				Notice that because arrays are 0-indexed, the very last element has an index of the array's length <i>minus one</i>.
			</p>
			<p>
				As you can see in the above image, the array index is the <i>key</i>, while the value which the key refers to is quite simply the value.
				To refer to any element in the array, we can use the index to retrieve or modify the correlated value. Thus it is a simple key-value datastructure.
			</p>
			<p>
				At this point I would be remiss to not talk about <i>strings</i>.
				A string is a type of array, but it is so special that in some languages (such as Python) it counts as a primitive data type.
				A string is an array of chars, which basically means that it is a word or collection of words.
				For example, "Hello World" is a string and an array of characters.
				We would say that the length of the string is 11 elements (characters) long, and it occupies indices 0 to 10.
				The space character would have an index of 5.
				Please note that when using arrays, the term 'subscript' rather than 'index' is sometimes used; this has nothing to do with subscript text in wordprocessing.
			</p>
		</h3>
		<table>
			<tr>
				<th>Index:</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>4</td>
				<td>5</td>
				<td>6</td>
				<td>7</td>
				<td>8</td>
				<td>9</td>
				<td>10</td>
			</tr>
			<tr>
				<th>Value:</td>
				<td>H</td>
				<td>e</td>
				<td>l</td>
				<td>l</td>
				<td>o</td>
				<td> </td>
				<td>W</td>
				<td>o</td>
				<td>r</td>
				<td>l</td>
				<td>d</td>
			</tr>
		</table>
		<h3>
			<p>
				Now, let's talk about <i>dictionaries</i>, also known as maps.
				Like the name implies, these map a key to a value.
				The difference between an array and a dictionary is that in an array, the keys have to be integers, and the values have a specific order;
				in a dictionary, however, the keys are characters or strings.
				For example, we could have a map/dictionary with a set of key-value pairs like this:
			</p>
		</h3>
		<table>
			<tr>
				<th>Key</td>
				<th>Value</td>
			</tr>
			<tr>
				<td>"First Name"</td>
				<td>"John"</td>
			</tr>
			<tr>
				<td>"Last Name"</td>
				<td>"Smith"</td>
			</tr>
			<tr>
				<td>"Age"</td>
				<td>"32"</td>
			</tr>
			<tr>
				<td>"City"</td>
				<td>"Seattle"</td>
			</tr>
			<tr>
				<td>"State"</td>
				<td>"Washington"</td>
			</tr>
		</table>
		<h3>
			<p>
				They don't have a specific order; we refer to them not using an integer index, but we using the string key.
				Using our cups-on-a-table analogy, the cups are now settled on the table in no particular order, and they are labeled not with a number but with a word (really a string or a character).
			</p>
		</h3>
		
		<h2>Variables</h2>
		
		<h3>
			<p>
				Now that we've established what data is, we should ask how we are to manipulate it.
				To do this, we have to use the concept of a variable; variables allow us to store, modify, and compare the values of data in our programs.
				A variable normally must be 'declared', meaning we tell the computer what the name of the variable is (how we will refer to it in our code) and what datatype it will be.
				This lets the computer know in advance how much space to reserve for it: if we declare a byte type variable called x, it knows it only needs to allocate 8 bits of memory for it.
				In some languages, however, we don't even need to tell the computer what type a variable will be: it will figure it out from context.
				In Java, I might declare a variable which stores the number of cats like so:
			</p>
			<div  class="codeinset"><code>int numCats;</code></div>
			<p>
				Now, the computer knows that the variable <code>numCats</code> will be an int type (32 bit integer) variable, and can allocate the necessary space for it.
			</p>
			<p>
				The next logical thing to learn to do is to set the value of a variable. We do this with the <i>assignment operator</i>, which in most languages is '='.
				We can either do variable assignment after the declaration, or at the exact same time.
				As another example in Java, we could have the following code:
			</p>
			<div class="codeinset">
				<code>int x;</code><br>
				<code>x = 5;</code>
			</div>
			<p>or we could have:</p>
			<div class="codeinset">
				<code>int x = 5;</code>
			</div>
			<p>
				Either would be acceptable ways to declare the integer x and assign it to 5.
				The only difference is that the first way uses two <i>statements</i>, which are a single instruction or line of code, while the second way only uses one.
				Computer code is essentially made up of many many individual statements, which each do one small thing.
				The computer <i>executes</i> (meaning it conducts the actions the statement directs it to) the statements starting from the top of the program, going statement by statement until it reaches the end, barring special structures like conditionals and loops, which we'll learn about later.
				Together, this multitude of small individual actions combine as algorithms and can do powerful things.
				Different programming languages use different <i>syntax</i>, which is like the grammar and punctuation of programming, to indicate what is a statement, but the concept remains the same.
				Finally, note that when using the assignment operator, the value on the right is assigned to the variable on the left.
			</p>
		</h3>
		
		<h2>Operators</h2>
		
		<h3>
			<p>
				Above, we learned about the assignment operator '=', which allows us to set the value of a variable.
				Now, we will want to manipulate that value, and we'll do so using <i>operators</i>.
				To simplify a bit, an operator is essentially an instruction for what to do with some number of <i>operands</i>.
				A <i>binary</i> operator acts on two operators, while a <i>unary</i> operator acts on only one.
				In programming, there are a few common operators which fall into the following categories: arithmetic, relational, logical, unary, and bitwise/bitshift.
				I'm going to skip the bitwise/bitshift operators right now, because I already covered them in the <a href="binary-numbers.html">binary numbers</a> page.
			</p>
			<p><u>Arithmetic Operators</u></p>
			<p>
				Whether you recognize it or not, you already know the arithmetic operators.
				These are operators such as <span class="nowrap">addition (+)</span>, <span class="nowrap">subtraction (-)</span>, <span class="nowrap">multiplication (*)</span>, and <span class="nowrap">division (/)</span>.
				I will assume that you already know how these work.
				You may or may not know the last one, <span class="nowrap"><a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modulus</a> (%)</span>, though, so I will explain it.
			</p>
			<p>
				One way to think of modulus is as the 'remainder operator'.
				Just as the division problem <span class="nowrap">13 / 4</span> will yield 3.25, <span class="nowrap">13 % 4</span> <span class="nowrap">('thirteen modulus 4')</span> yields 1, because the remainder was 1.
				If a number divides evenly into another number, the modulus will be 0: <span class="nowrap">42 % 7 = 0</span> because <span class="nowrap">7 * 6 = 42</span>; in other words, because 42 divides evenly by 7 to yield 6 and 0 left over, the modulus is 0.
				Similarly, <span class="nowrap">12 / 7 = 1 remainder 5</span>, which is equal to 1 and 5 sevenths.
				If we were to do <span class="nowrap">12 % 7</span>, the result would be 5, because the remainder of the division problem is 5.
			</p>
			<p>
				The other way to think of modulus is where numbers 'reset' after reaching a certain value, or 'wrap around'.
				For example, if I wanted to do 12 modulus 7, I would start counting up from 1 to 12, but when I run across 7, I reset to 0.
				My counting would look like this: 1, 2, 3, 4, 5, 6, 0, 1, 2, 3, 4, 5. Thus 12 modulus 7 equals 5. Here's what counting to 20 looks like, modulus 4:
			</p>
		</h3>
		<table>
			<tr>
				<th>Normal Counting:</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>4</td>
				<td>5</td>
				<td>6</td>
				<td>7</td>
				<td>8</td>
				<td>9</td>
				<td>10</td>
				<td>11</td>
				<td>12</td>
				<td>13</td>
				<td>14</td>
				<td>15</td>
				<td>16</td>
				<td>17</td>
				<td>18</td>
				<td>19</td>
				<td>20</td>
			</tr>
			<tr>
				<th>Counting Modulus 4:</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>0</td>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>0</td>
			</tr>
		</table>
		<h3>
			<p>
				A familiar example of modulus from your everyday life is a clock.
				A clock counts modulus 12, because when you get to 12, you actually reset to 0.
				When you convert from miliary time to civilian time, you are really dividing military time by 12 and taking the remainder. 14 o'clock is <span class="nowrap">14 % 12 = 2</span> o'clock.
			</p>
			<p><u>Relational Operators</u></p>
			<p>
				You probably already know the relational operators, so I'm just going to give them a quick once-over.
				Relational operators compare values and determine which is greater or lesser.
				<i>Unlike in math, these operators don't just tell us a fact about size comparisons; these are fully fledged operators and return an answer, like any other operator.</i>
				The operator will return a True (1) or a False (0) value, depending on if the statement they are in is true or false.
				So for example, <code>5 &lt; 3</code> will return false or 0, because clearly 5 is actually greater than 3, not less than it.
				It's very important to stress that to the computer, a true/false value and a 1/0 value are both represented as a single bit of data which can be 1 or 0.
				They are interchangeable in most situations.
			</p>
			<p>
				There are size relational operators: less than (&lt;), less than or equal to (&le; or &lt;=), greater than (&gt;), greater than or equal to (&ge; or &gt;=), equals (==), and not equals (!=).
				Note that we normally write less than or equal to as '&lt;=' and greater than or equal to as '&gt;='.
				Also note that when we want to test if two things are equal (remember that we'll receive a 1 (true) or 0 (false) value back) we have to use a double equals sign.
				This is because the single equals is already reserved for assignment.
				<code>x = 5</code> uses the assignment operator and will set the variable x to be 5, while <code>x == 5</code> uses the equality comparison operator and will evaluate to 1 (true) if x is indeed equal to 5, and it will evaluate to 0 (false) otherwise.
			</p>
			<p><u>Logical Operators</u></p>
			<p>
				There are three main logical operators: AND, OR, and NOT.
				Like the relational operators, they return a true or false value based on their operands' values.
				However, they differ in that where the relational operators operate on integers, they operate on true and false values.
				
				I'll first explain what each one does, then show you a <i>truth table</i> for each one.
				A truth table is a table which shows the output of a logical operation given some certain inputs.
				It works similar to a times table, where the top and left columns represent the operands, while the interior represents the results.
			</p>
			<p>
				AND (sometimes represented as &&) evaluates to true if both of its operands are 1 (true), and evaluates to false for any other case.
			</p>
		</h3>
		<table>
			<tr>
				<th>&&</td>
				<th>True</td>
				<th>False</td>
			</tr>
			<tr>
				<th>True</td>
				<td>True</td>
				<td>False</td>
			</tr>
			<tr>
				<th>False</td>
				<td>False</td>
				<td>False</td>
			</tr>
		</table>
		<h3>
			<p>
				As you can see, <code>True && True = True</code>, <code>True && False = False</code>, <code>False && True = False</code>, and <code>False && False = False</code>.
			</p>
			<p>
				OR (sometimes represented as ||) evaluates to false if both of its operands are 0 (false), and evaluates to true for any other case.
				In this way, it is like the inverse of AND.
			</p>
		</h3>
		<table>
			<tr>
				<th>||</td>
				<th>True</td>
				<th>False</td>
			</tr>
			<tr>
				<th>True</td>
				<td>True</td>
				<td>True</td>
			</tr>
			<tr>
				<th>False</td>
				<td>True</td>
				<td>False</td>
			</tr>
		</table>
		<h3>
			<p>
				As you can see, <code>True && True = True</code>, <code>True && False = True</code>, <code>False && True = True</code>, and <code>False && False = False</code>.
			</p>
			<p>
				NOT (sometimes represented as !) is also called the <i>logical complement</i>. It is a unary operator, meaning it operates on only one value.
				NOT flips the value of whatever it is applied to, so NOT True becomes False and NOT False becomes True.
			</p>
		</h3>
		<table>
			<tr>
				<th>Input</td>
				<th>True</td>
				<th>False</td>
			</tr>
			<tr>
				<th>!Input</td>
				<td>False</td>
				<td>True</td>
			</tr>
		</table>
		<h3>
			<p><u>Unary Operators</u></p>
			<p>
				There are a few operators which operate on only one value which are important to talk about.
				They don't appear in all languages, but they are important in the ones they do appear in.
				They are: minus/negate (-), increment (++), and decrement(--).
			</p>
			<p>
				Minus does exactly what it says it does. It takes the value you give it and returns -1 times that value. So if x is equal to 5, <code>-x</code> returns -5.
			</p>
			<p>
				Increment and decrement are <i>shorthand operators</i>, meaning they take a longer operation and make it shorter to write out.
				Increment simply results in the value plus one, while decrement results in the value minus one.
				So if x is equal to 17, <code>x++</code> equals 18, and <code>x--</code> equals 16.
			</p>
		</h3>
		
		<h2>Concatenation</h2>
		
		<h3>
			<p>
				Concatenation is concept which very similar to the addition operator, but instead of acting on numbers, it acts on strings.
				Concatenation allows the joining of many strings together to create a larger string.
				Normally, concatenation uses the '+' operator.
				Let's look at some examples:
			</p>
			<div class="codeinset">
				<code>"Hello" + " " + "World" = "Hello World"</code><br>
				<code>"My " + "name " + "is " + "[redacted]." = "My name is [redacted]."</code>
			</div>
			<p>
				The first thing to notice is that strings are contained within quotes (").
				In the first example, we have a string saying "Hello", and then we add it to a string containing a single space character, and then we add "World" to that.
				This, predictably, results in the string <span class="nowrap">"Hello World".</span>
				The second example is also very self-explanatory.
			</p>
			<p>
				But now we run into a conundrum: if strings are enclosed by quotes, how do we put a quote <i>inside</i> a string? We do this using <i>escape characters</i>.
				An <a href="https://en.wikipedia.org/wiki/Escape_character">escape character</a> is normally written with a backslash (\) and then a specific character, which then becomes a new character.
				It's similar to the character encoding we discussed above. Some examples of escape characters:
			</p>
			<div class="codeinset">
				<code>"\"We should take a trip\"," + " " + " he said." = "We should take a trip", he said.</code><br>
				<code>"\'X\' " + "is " + "my " + "favorite " + "letter." = 'X' is my favorite letter.</code>
			</div>
			<p>
				For this example, I used concatenation, escape characters, and enclosed my strings on the left side, while on the right side I wrote the result in plain text.
				There are many escape characters, but here is a list of the most useful ones:
			</p>
			<p>
				- \" represents a quotation mark (").<br>
				- \' represents an apostrophe (').<br>
				- \\ represents a backslash (\).<br>
				- \t represents a tab character, which is like hitting the <kbd>TAB</kbd> key.<br>
				- \n represents a '<a href="https://en.wikipedia.org/wiki/Newline">newline</a>' character, which is like hitting the <kbd>ENTER</kbd> key.<br>
				- \b represents a backspace character, which is like hitting the <kbd>BACKSPACE</kbd> key.<br>
				- \r represents a '<a href="https://en.wikipedia.org/wiki/Carriage_return">carriage return</a>', which returns the cursor to the beginning of the line.<br>
			</p>
		</h3>
		
		<h2>Casting</h2>
		
		<h3>
			<p>
				Casting, where a value represented in one datatype is converted to another equivalent value represented by a different datatype, is an important concept to understand.
				In some languages, your program might require you to have a value in a certain type.
				This might require turning an int into a double or a double into an int (note that if we convert a double, such as 5.492, into an int, it will become just 5, and we'll lose some data precision).
				We might also have to turn a character into its numeric ASCII representation or vice versa, or likewise with its unicode representation.
				We could have to turn an int into a string (so the number 10 becomes the string "10"), or back (so the string "15" becomes the int 15).
				There are many possibilities, so being aware of this concept may come in useful when you are programming.
			</p>
		</h3>
		
		<h2>Expressions</h2>
		
		<h3>
			<p>
				Now that we've learned about datatypes, variables, and operators, we're ready to learn about expressions.
				Expressions in CS (Computer Science) are very similar to expressions in math, in that they are a mix of values and operations which need to be 'evaluated' to give a final result.
				Like mathematical expressions, they have a specific order of operations which is an internationally-recognized standard of which operations take precedence over which others.
				In math, you probably learned about PEMDAS (Parenthesis, Exponentiation, Multiplication/Division, Addition/Subtraction) and evaluating from left to right.
				In computer science, it's pretty much the same order, but with some additional operators.
				A good reference on CS order of operations is <a href="https://www.computerhope.com/jargon/o/order-of-operations.htm">this</a> page, particularly the section on C's order of operations (C is a programming language).
				Don't worry about the operations you don't know about yet.
				As the page says, some languages require programmers to define an order of operations, or simply go left to right; however, most languages have an order of operations similar to C's.
			</p>
			<p>
				The best way to learn expressions is just to try a bunch of them.
				So <a href="">here</a> is a large list of sample expressions and explanations for you to peruse at your leisure.
			<p>
		</h3>
		
		<h2>De Morgan's Law</h2>
		
		<h3>
			<p>
				If you look at the <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">wikipedia page for De Morgan's Law</a> you will be likely very confused and somewhat intimidated.
				However, it is really quite simple.
				De Morgan's law essentially tells us what happens when we take an expression, such as
				<code>a AND b &lt; c</code>,
				and stick a NOT in front of the whole thing, like so:
				<code>NOT (a AND b &lt; c)</code>.
				What we have to do is systematically go through the expression, replacing each relational or logical operator with its inverse.
				So <code>NOT (a AND b &lt; c) = (a OR b &gt;= c)</code>.
				Here's a handy chart of each operator we need to replace and its inverse:
			</p>
		</h3>
		<table>
			<tr>
				<th>Operator</th>
				<th>Inverse</th>
			</tr>
			<tr>
				<td>AND</td>
				<td>OR</td>
			</tr>
			<tr>
				<td>OR</td>
				<td>AND</td>
			</tr>
			<tr>
				<td>NOT</td>
				<td>NOT</td>
			</tr>
			<tr>
				<td>&gt;</td>
				<td>&lt;=</td>
			</tr>
			<tr>
				<td>&lt;</td>
				<td>&gt;=</td>
			</tr>
			<tr>
				<td>&gt;=</td>
				<td>&lt;</td>
			</tr>
			<tr>
				<td>&lt;=</td>
				<td>&gt;</td>
			</tr>
			<tr>
				<td>==</td>
				<td>!=</td>
			</tr>
			<tr>
				<td>!=</td>
				<td>==</td>
			</tr>
		<table>
		<h3>
			<p>
				Some examples:
			</p>
			<div class="codeinset">
				<code>NOT(y &gt; x OR a &lt; b) becomes (y &lt;= x AND a &gt;= b)</code><br>
				<code>NOT(numDogs != numCats) becomes (numDogs == numCats)</code><br>
				<code>NOT(vec1 &gt; vec2 AND vec3 &gt;= vec4) becomes (vec1 &lt;= vec2 OR vec3 &lt; vec4)</code><br>
			</div>
		</h3>
		
		<h2>Control Structures</h2>
		
		<h3>
			<p>
				<i>Control structures</i> are integral parts of programs as they allow us to set the 'flow' of the program.
				There are a few types of control structures: sequencial, conditional, and iterative (looping).
				These basically govern which statements will be executed and in what order, allowing us to <i>implement</i> many more algorithms.
				To implement an algorithm means to take the central idea of the algorithm, such as summing up a list of numbers, and write code which performs that algorithm.
			</p>
		</h3>
		
		<h2>Sequence</h2>
		
		<h3>
			<p>
				Sequential execution of code is the normal, vanilla default for how code is executed.
				If we have several statements in a row, they will be executed from top to bottom and left to right, barring the introduction of other control structures.
				In the example below, statements will be executed in order according to their numbers.
			</p>
			<div class="codeinset">
				<code>statement 1</code><br>
				<code>statement 2</code><br>
				<code>statement 3</code><br>
				<code>statement 4</code><br>
			</div>
			<p>
				When programming, it's best to think of the computer like a person literally reading your program.
				A person would have one instruction in their head at a time, and would move to the next instruction depending on the placement of your control structures.
				Similarly, program execution moves through your program one statement at a time, directed by the control structures.
			</p>
		</h3>
		
		<h2>Conditionals</h2>
		
		<h3>
			<p>
				Conditionals are useful control structures which allow us to create <i>branches</i>, which basically say "If thing X is true, do thing Y."
				Unsurprisingly, the main conditional structure is called the <code>if</code> conditional, which takes the form of a <i>block</i>.
				The block of code starts at the <code>if</code> <i>keyword</i> and goes all the way to the closing brace (or curly-brace, if you prefer that).
				A keyword is a special word which tells the computer to do something specific where it appears, and as such cannot be used as a variable name.
				An <code>if</code> statement looks something like this:
			</p>
			<div class="codeinset">
				<code>IF (some condition):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do this</code><br>
				<code>}</code><br>
			</div>
			<p>
				In the code above, if the expression <code>some condition</code> evaluates to True, the statement <code>do this</code> is run.
				If the expression evaluates to False, the statement inside the block is not executed, and the entire <code>if</code> block is skipped.
			</p>
			<p>
				A slightly more upgraded conditional is the <code>else if</code> conditional.
				This has to follow an <code>if</code> conditional, and forms chains of linked conditionals.
				It basically does what it says:
				if the original <code>if</code> statement fails (meaning the condition was not met), the computer will check if the <code>else if</code> condition is true, and if so, will 'go into' that block.
				'Go into' is programmer speak for execution moving into a specific code block or section of code.
				If neither condition passes, both blocks will be skipped, similar to the single <code>if</code> block above; if the first condition passes, the whole <code>else if</code> block will be skipped, and its condition will not even be evaluated.
				This is because it is an <code><i>else</i> if</code>: it only can happen if the first possibility doesn't.
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition B):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
			</div>
			<p>
				In this case, if condition A is met, <code>do a</code> is executed.
				If condition A is not met, but condition B is, <code>do b</code> will b executed.
				If neither condition A nor condition B are met, the whole block will be skipped.
			</p>
			<p>
				We can actually string as many <code>else if</code> blocks together as we want, forming long conditional chains.
				Here's an example with three <code>else if</code> blocks:
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition B):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition C)</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
				<code>ELSE IF(condition D)</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do d</code><br>
				<code>}</code><br>
			</div>
			<p>
				This is actually why we call an if statement a branch: in this block, one statement (and only one) will be executed, and the different possibilities stick out like branches from a tree.
				If any condition is met, the corresponding statement is executed, and then execution drops down to past the last <code>else if</code> block, even if multiple conditions are true.
				If condition A and B are true, but C and D are false, only <code>do a</code> will actually be executed.
				The computer won't even check to see if conditions B, C, and D are true or not.
				This is why the order matters when you are programming.
				If none of the conditions is met, nothing inside the chain runs (is executed) and execution moves down below the last <code>else if</code>.
			</p>
			<p>
				Finally, there is one more conditional, the humble <code>else</code> block.
				It functions much as the <code>else if</code> block from above, in that it has to follow an <code>if</code> or <code>else if</code> statement.
				It also only executes if all conditional statements linked to it above don't execute. Once you put an else, you cannot link any more conditionals below it.
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
			</div>
			<p>
				It's quite self-explanatory: if A is true, do a; if A is not true, do b.
				If A is true, b will not happen, because b only happens if A is not true.
				Please note that in this case, unlike an <code>if</code> or <code>else if</code> chain, where no statement is guaranteed to be executed, either statement <code>a</code> or statement <code>b</code> will be executed.
				We may not know ahead of time which one it will be, but we are guaranteed that one of them will run.
			</p>
			<p>
				We can also use the <code>else</code> block in conjunction with the <code>else if</code> block:
			</p>
			<div class="codeinset">
				<code>IF (condition A):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition B):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>ELSE IF (condition C)</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
				<code>ELSE</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do d</code><br>
				<code>}</code><br>
			</div>
			<p>
				In this chain, one statement will run, unlike the chain made up only of <code>else if</code> blocks, where there is a possibility of no statement in the chain running.
				Either a, b, or c will be executed, depending on which is the first true condition out of conditions A, B, or C.
				If none of those conditions are true, d will run.
			</p>
			<p>
				The chain-like nature of <code>else if</code> blocks means that an <code>if</code> followed by two <code>else if</code> blocks can be very different from three <code>if</code> blocks:
			</p>
			Code Snippet #1:
			<div class="codeinset">
				<code>IF A:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>ELSE IF B:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>ELSE IF C:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
			</div>
			Code Snippet #2:
			<div class="codeinset">
				<code>IF A:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do a</code><br>
				<code>}</code><br>
				<code>IF B:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do b</code><br>
				<code>}</code><br>
				<code>IF C:</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do c</code><br>
				<code>}</code><br>
			</div>
			<p>
				In the first code snippet, which is a single conditional chain made of three blocks, only one of a, b, and c will run, or none of them will run.
			</p>
			<p>
				In the second code snippet, which is three independent conditional blocks, execution doesn't drop to the end of the chain when a statement is run because there <i>is</i> no chain.
				There is a possibility of a, b, <i>and</i> c running, because the only thing determining whether a statement runs is its associated conditional.
				Just because A is true and a runs doesn't mean B won't be true, causing b to run. a and b could run, or a and c, or b and c, or just a, just b, just c, or all three.
				If A, B, and C all turn out to be false, none of a, b, or c could run.
			</p>
		</h3>
		
		<h2>Loops</h2>
		
		<h3>
			<p>
				The last programming structure is the iterative structure, which essentially involves running the same code multiple times.
				Different programming languages have various syntaxes and structures to do this, but almost all of them have <code>while</code> loops, so we'll focus on those.
				A while loop is very similar to an <code>if</code> conditional: it has a condition (which should be an expression which evaluates to true or false) and a body (a set of statements to be run).
				However, the difference is that where an <code>if</code> conditional only runs the block once, a <code>while</code> loops runs the block of code indefinitely, only stopping if the condition becomes false.
				Here's an example of a basic while loop:
			</p>
			<div class="codeinset">
				<code>WHILE (condition):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;do this</code><br>
				<code>}</code><br>
			</div>
			<p>
				To understand it a little better, we need to look at a real example:
			</p>
			<div class="codeinset">
				<code>int i = 0;</code><br>
				<code>WHILE (i &lt; 10):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;i = i++;</code><br>
				<code>}</code><br>
			</div>
			<p>
				If this is the first real segment of code you've seen, don't worry: we'll break it down.
				The first statement tells the computer that we are going to create a variable called <code>i</code>.
				This variable will be an <code>int</code> type variable and will have the value of 0.
				Now, we come to a <code>while</code> loop, where our condition says that the code inside the while loop will be executed if the variable <code>i</code> is less than 10.
				Finally, the code inside the while loop sets the value of the variable <code>i</code> to whatever <code>i</code> is, plus one (remember that the increment operator (++) increases its operand's value by one).
			</p>
			<p>
				This last bit may be confusing for you, especially if you look at it from a math-tinted lense: in math, statements of equality must be true.
				However, this is computer science now, and we aren't making a statement of equality (that would be <code>==</code>): we are assigning a variable to a value.
				When the computer does this, it first evaluates whatever expression is on the right, and then sets the variable on the left to that expression.
				We can then see that <code>i++</code> evaluates to i + 1, so the whole statement sets the value of <code>i</code> to whatever <code>i</code> was, plus one.
			</p>
			<p>
				So what does this code actually do? For beginning CS students, it is normally very helpful to create a table:
			</p>
		</h3>
		<table>
			<tr>
				<th>loop #</th>
				<th>val <code>i</code></th>
			</tr>
			<tr>
				<td>0</td>
				<td>0</td>
			</tr>
			<tr>
				<td>1</td>
				<td>1</td>
			</tr>
			<tr>
				<td>2</td>
				<td>2</td>
			</tr>
			<tr>
				<td>3</td>
				<td>3</td>
			</tr>
			<tr>
				<td>4</td>
				<td>4</td>
			</tr>
			<tr>
				<td>5</td>
				<td>5</td>
			</tr>
			<tr>
				<td>6</td>
				<td>6</td>
			</tr>
			<tr>
				<td>7</td>
				<td>7</td>
			</tr>
			<tr>
				<td>8</td>
				<td>8</td>
			</tr>
			<tr>
				<td>9</td>
				<td>9</td>
			</tr>
			<tr>
				<td>10</td>
				<td>10</td>
			</tr>
		</table>
		<h3>
			<p>
				On the left hand side we have the number of completed loops, while on the right hand side, we have the value of <code>i</code>.
				The 0th loop is the state of our variable before the loop starts.
				As you can see, each time the loop runs, <code>i</code> is incremented by one.
				After the 10th iteration, the value of <code>i</code> equals ten, which makes our condition <code>i &lt; 10</code> false.
				This will cause the loop to end and program execution will move on.
			</p>
			<p>
				So this code doesn't actually do anything, per se, because it just runs 10 times and then program execution moves beyond the loop.
				However, we could easily modify this code to do something, by putting some additional statements in the block:
			</p>
			<div class="codeinset">
				<code>int i = 0;</code><br>
				<code>WHILE (i &lt; 10):</code><br>
				<code>{</code><br>
				<code>&emsp;&emsp;i = i++;</code><br>
				<code>&emsp;&emsp;do something;</code><br>
				<code>&emsp;&emsp;do something else;</code><br>
				<code>}</code><br>
			</div>
		</h3>
		
		<h2>In Conclusion</h2>
		
		<h3>
			<p>
				So today we learned:<br>
				- Binary numbers are how computers store data.<br>
				- Algorithms are sets of instructions which manipulate data.<br>
				- Datatypes are various ways of representing/storing data. <br>
				- Primitive datatypes are those which are built in to a specific programming language.<br>
				- Data structures are ways to organize data so we can store, modify, and retrieve it.<br>
				- Arrays/Vectors and Dictionaries/Maps are datastructures which use a key-value organizational scheme.<br>
				- Array keys are integers, while dictionary keys are strings.<br>
				- Strings are arrays of characters.<br>
				- Variables allow us to modify the values of data within our code.<br>
				- In CS, we use Arithmetic, Relational, Logical, Unary, and Bitwise operators.<br>
				- Concatenation is like addition, but for strings.<br>
				- Escape characters allow us to represent certain reserved characters, such as " or '.<br>
				- Casting allows us to change a value stored as one datatype into an equivalent value stored as another datatype.<br>
				- Expressions are combinations of values and operators which can be evaluated using operator precedence (order of operations).<br>
				- De Morgan's Law guides us on how to change an expression with a NOT at the front.<br>
				- There are three control structures: sequence, conditional, and iterative.<br>
				- There are three conditional types: <code>if</code>, <code>else if</code>, and <code>else</code>.<br>
				- A <code>while</code> loop acts like a repeating <code>if</code> statement.
			</p>
			<p>
				Thank you for reading through this, and I hope you learned something.
				Next, please check out the <a href="functional-programming.html">Functional Programming</a> or <a href="oop-programming.html">Object Oriented Programming</a> courses.
			</p>
		</h3>
	</div>
</body>

</html>